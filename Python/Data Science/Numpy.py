import numpy as np

# Вектор-строку можно задать следующим образом:
# v_hor_np = np.array([1, 2])
# print(v_hor_np)


# Если необходимо создать нулевой или единичный вектор (вектор, у которого все
# элементы либо нули, либо единицы), то можно использовать специальные функции
# из библиотеки Numpy

# Создадим нулевую вектор-строку, состоящую из пяти элементов:
# v_hor_zeros_v1 = np.zeros((5,))
# print(v_hor_zeros_v1)

# В случае, если требуется построить вектор-строку так, чтобы он сам являлся
# элементом массива, это может понадобиться если вектор, в последующем, нужно будет транспонировать

# v_hor_zeros_v2 = np.zeros((1, 5))
# print(v_hor_zeros_v2)

# Аналогично построим единичную вектор-строку:

# v_hor_one_v1 = np.ones((5,))
# print(v_hor_one_v1)

# v_hor_one_v2 = np.ones((1, 5))
# print(v_hor_one_v2)

# Вектор-столбец

# В общем виде вектор столбец можно задать следующим образом:

# v_vert_np = np.array([[1], [2]])
# print(v_vert_np)

# Рассмотрим способы создания нулевых и единичных векторов-столбцов. Построим
# нулевой вектор-столбец:

# v_vert_zeros = np.zeros((5, 1))
# print(v_vert_zeros)

# Единичный вектор-столбец можно создать с помощью функции ones():

# v_vert_ones = np.ones((5, 1))
# print(v_vert_ones)


# Квадратная матрица
# В Numpy можно создать квадратную матрицу с помощью метода array():
# m_sqr_arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# print(m_sqr_arr)

# В Numpy есть еще одни способ создания матриц - это построение объекта типа
# matrix с помощью одноименного метода. Задать матрицу можно в виде списка:

# m_sqrt_mx = np.matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# print(m_sqrt_mx)

# Также доступен стиль Matlab, когда между элементами ставятся пробелы, а строки
# разделяются точкой с запятой, при этом такое описание должно быть передано в
# виде строки:

# m_sqrt_dx = np.matrix("1 2 3; 4 5 6; 7 8 9")
# print(m_sqrt_dx)


# Диагональная матрица

# Диагональную матрицу можно построить вручную, задав только значения элементам
# на главной диагонали:

# m_diag = [[1, 0, 0], [0, 5, 0], [0, 0, 9]]
# m_diag_np = np.matrix(m_diag)
# print(m_diag_np)

# Библиотека Numpy предоставляет инструменты, которые могут упростить
# построение такой матрицы.

# Первый вариант подойдет в том случае, если у вас уже есть матрица, а вы из нее
# хотите сделать диагональную. Создадим матрицу размера 3x3:
# m_sqr_mx = np.matrix("1 2 3; 4 5 6; 7 8 9")
# Извлечем ее главную диагональ:
# diag = np.diag(m_sqr_mx)
# print(diag)

# Построим диагональную матрицу на базе полученной диагонали:
# m_diag_np = np.diag(np.diag(m_sqr_mx))
# print(m_diag_np)


# Единичная матрица

# Создадим единичную матрицу на базе списка, который передадим в качестве
# аргумента функции matrix():

# m_e = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
# m_e_np = np.matrix(m_e)
# print(m_e_np)

# Такой способ не очень удобен, к счастью для нас, для построения такого типа
# матриц в библиотеке Numpy есть специальная функция — ey
# m_eye = np.eye(3)
# print(m_eye)

# В качестве аргумента функции передается размерность матрицы, в нашем примере -
# это матрица 3x3. Тот же результат можно получить с помощью функции identity():

# m_idn = np.identity(3)
# print(m_idn)


# Нулевая матрица

# m_zeros = np.zeros((3, 3))
# print(m_zeros)


# Транспонирование матрицы

# A = np.matrix("1 2 3; 4 5 6")
# print(A)

# A_t = A.transpose()
# print(A_t)

# Существует сокращенный вариант получения транспонированной матрицы, он
# удобен для практического использования:

# print(A.T)

# Дважды транспонированная матрица равна исходной матрице:

# A = np.matrix('1 2 3; 4 5 6')
# print(A)
# R = (A.T).T
# print(R)


# Транспонированное произведение матриц равно произведению
# транспонированных матриц, расставленных в обратном порядке:

# A = np.matrix('1 2; 3 4')
# B = np.matrix("5 6; 7 8")
# L = (A.dot(B)).T
# R = (B.T).dot(A.T)

# print(L)
# print(R)

# В данном примере, для умножения матриц, использовалась функция dot() из
# библиотеки Numpy.


# Определители исходной и транспонированной матрицы совпадают:

# A = np.matrix("1 2; 3 4")
# A_det = np.linalg.det(A)
# A_T_det = np.linalg.det(A.T)
# print(format(A_det, ".9g"))
# print(format(A_T_det, ".9g"))

# Ввиду особенностей Python при работе с числами с плавающей точкой, в данном
# примере при вычислении определителя рассматриваются только первые девять
# значащих цифр после запятой (за это отвечает параметр '.9g').


# Умножение матриц

# Умножать можно только матрицы, отвечающие следующему
# требованию: количество столбцов первой матрицы должно быть равно числу
# строк второй матрицы.

# Решим задачу умножения матриц на языке Python. Для этого будем использовать
# функцию dot() из библиотеки Numpy:

# A = np.matrix("1 2 3; 4 5 6")
# B = np.matrix("7 8; 9 1; 2 3")
# C = A.dot(B)
# print(C)

# Умножение матриц в общем виде не коммутативно. Это означает, что
# для матриц не выполняется правило независимости произведения от перестановки
# множителей

# Произведение заданной матрицы на нулевую матрицу равно нулевой матрице


# Определитель матрицы

# A = np.matrix("-4 -1 2; 10 4 -1; 8 3 1")
# print(A)

# Для вычисления определителя этой матрицы воспользуемся функцией det() из
# пакета linalg.

# print(np.linalg.det(A))

# Определитель матрицы остается неизменным при ее
# транспонировании:

# Для округления чисел будем использовать функцию round().
# A = np.matrix("-4 -1 2; 10 4 -1; 8 3 1")
# print(A)
# print(A.T)

# det_A = round(np.linalg.det(A), 3)
# det_A_t = round(np.linalg.det(A.T), 3)
# print(det_A)
# print(det_A_t)


# Если у матрицы есть строка или столбец, состоящие из нулей, то
# определитель такой матрицы равен нулю

# При перестановке строк матрицы знак ее определителя меняется на
# противоположный

# Если у матрицы есть две одинаковые строки, то ее определитель
# равен нулю

# Если все элементы строки или столбца матрицы умножить на какое-то
# число, то и определитель будет умножен на это число


# Если все элементы строки или столбца можно представить как сумму
# двух слагаемых, то определитель такой матрицы равен сумме определителей двух
# соответствующих матриц


# Если строка или столбец матрицы является линейной комбинацией
# других строк (столбцов), то определитель такой матрицы равен нулю:

# A = np.matrix("-4 -1 2; 10 4 -1; 8 3 1")
# print(A)
# k = 2
# A[1, :] = A[0, :] + k * A[2, :]
# print(round(np.linalg.det(A), 3))

# Если матрица содержит пропорциональные строки, то ее определитель
# равен нулю:

# A = np.matrix("-4 -1 2; 10 4 -1; 8 3 1")
# print(A)
# k = 2
# A[1, :] = k * A[0, :]
# print(A)
# print(round(np.linalg.det(A), 3))


#  Обратная матрица

# Введем понятие союзной матрицы. Союзная матрица A^* строится на базе
# исходной путем замены всех элементов матрицы на их алгебраические
# дополнения.

# Теперь, зная как вычислять определитель и присоединенную матрицу, мы можем
# определить матрицу A^(-1), обратную матрице A:
# A^(-1) = 1/det(A)  * (A^*)^T

# Решим задачу определения обратной матрицы на Python. Для получения обратной
# матрицы будем использовать функцию inv():

A = np.matrix("1 -3; 2 5")
A_inv = np.linalg.inv(A)
print(A_inv)

# Обратная матрица произведения матриц равна произведению обратных матриц


